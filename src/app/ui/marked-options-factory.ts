import { MarkedOptions, MarkedRenderer } from 'ngx-markdown';
import { Hooks } from 'marked';

/**
 * Parses image sizing syntax from title attribute.
 * The title format is expected to be "width|height" (e.g., "200|150", "200|", "|150")
 * This is generated by preprocessing.
 */
const parseImageDimensionsFromTitle = (
  title: string | null,
): { width?: string; height?: string } => {
  if (!title) {
    return {};
  }

  // Check if title is in our custom format: "width|height"
  const match = title.match(/^(\d*)?\|(\d*)?$/);
  if (!match) {
    return {};
  }

  return {
    width: match[1] && match[1].length > 0 ? match[1] : undefined,
    height: match[2] && match[2].length > 0 ? match[2] : undefined,
  };
};

/**
 * Preprocess markdown to convert image sizing syntax into title attributes.
 * Converts: ![alt](url =WIDTHxHEIGHT) -> ![alt](url "WIDTH|HEIGHT")
 * This allows marked.js to parse it as a valid image with a title.
 */
const preprocessMarkdown = (markdown: string): string => {
  // Match: ![alt](url =WIDTHxHEIGHT) or ![alt](url =WIDTHx) or ![alt](url =xHEIGHT)
  // Capture groups: 1=alt, 2=url, 3=width, 4=height
  return markdown.replace(
    /!\[([^\]]*)\]\(([^\s)]+)\s+=(\d*)x(\d*)\)/g,
    (match, alt, url, width, height) => {
      // Create title attribute with width|height format
      const dimensions = `${width || ''}|${height || ''}`;
      return `![${alt}](${url} "${dimensions}")`;
    },
  );
};

export const markedOptionsFactory = (): MarkedOptions => {
  const renderer = new MarkedRenderer();

  renderer.checkbox = ({ checked }: { checked: boolean }) =>
    `<span class="checkbox material-icons">${checked ? 'check_box' : 'check_box_outline_blank'}</span>`;

  // In marked v17, we need to use this.parser.parseInline(tokens) to render inline content
  // Using a regular function to access 'this'
  renderer.listitem = function ({
    text,
    task,
    checked,
    tokens,
  }: {
    text: string;
    task: boolean;
    checked?: boolean;
    tokens: any[];
  }) {
    // In marked v17, task list items need to manually prepend the checkbox
    // Parse tokens to get rendered text with inline formatting (bold, italic, links, etc.)
    const renderedText = tokens ? this.parser.parseInline(tokens) : text;
    if (task) {
      const isChecked = checked === true;
      const checkboxHtml = `<span class="checkbox material-icons">${isChecked ? 'check_box' : 'check_box_outline_blank'}</span>`;
      return `<li class="checkbox-wrapper ${isChecked ? 'done' : 'undone'}">${checkboxHtml} ${renderedText}</li>`;
    }
    return `<li>${renderedText}</li>`;
  };

  // In marked v17, link renderer receives tokens that need to be parsed for inline content
  renderer.link = function ({
    href,
    title,
    tokens,
  }: {
    href: string;
    title?: string | null;
    tokens: any[];
  }) {
    const text = tokens ? this.parser.parseInline(tokens) : '';
    return `<a target="_blank" href="${href}" title="${title || ''}">${text}</a>`;
  };

  // Custom image renderer with support for sizing syntax
  // Note: indexeddb:// URLs are pre-resolved to blob: URLs before markdown rendering
  // The sizing dimensions are passed via the title attribute in "width|height" format
  renderer.image = ({
    href,
    title,
    text,
  }: {
    href: string;
    title: string | null;
    text: string;
  }) => {
    const { width, height } = parseImageDimensionsFromTitle(title);

    // Build width and height attributes (not style, as Angular sanitizer strips inline styles)
    const widthAttr = width ? ` width="${width}"` : '';
    const heightAttr = height ? ` height="${height}"` : '';

    // Only include title if it's not our custom dimension format
    const isCustomDimensionTitle = title && /^(\d*)?\|(\d*)?$/.test(title);
    const titleAttr = title && !isCustomDimensionTitle ? ` title="${title}"` : '';
    const srcAttr = ` src="${href}"`;

    return `<img alt="${text}"${srcAttr}${titleAttr}${widthAttr}${heightAttr} loading="lazy">`;
  };

  // In marked v17, paragraph renderer receives tokens that need to be parsed
  renderer.paragraph = function ({ tokens }: { tokens: any[] }) {
    const text = tokens ? this.parser.parseInline(tokens) : '';
    const split = text.split('\n');
    return split.reduce((acc, p, i) => {
      const result = /h(\d)\./.exec(p);
      if (result !== null) {
        const h = `h${result[1]}`;
        return acc + `<${h}>${p.replace(result[0], '')}</${h}>`;
      }

      if (split.length === 1) {
        return `<p>` + p + `</p>`;
      }

      return acc ? (split.length - 1 === i ? acc + p + `</p>` : acc + p) : `<p>` + p;
    }, '');
  };

  // NOTE: We intentionally do NOT override renderer.text for URL auto-linking.
  // In marked v17 with gfm: true, URLs are automatically detected and converted to links
  // by the lexer before they reach the text renderer. Custom URL linkification here
  // would cause double-processing and broken HTML (links inside links).

  const options: MarkedOptions = {
    renderer,
    gfm: true,
    breaks: false,
    pedantic: false,
  };

  // Add preprocessing hook to handle image sizing syntax
  const hooks = new Hooks();
  hooks.preprocess = preprocessMarkdown;
  options.hooks = hooks;

  return options;
};
